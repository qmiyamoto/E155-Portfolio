---
title: "Lab 2: Multiplexed 7-Segment Display"
---

## Introduction {#sec-intro}
In this lab, a time-multiplexer was implemented to switch between supplying power to two separate 7-segment displays, both of which were supposed to present a different hexadecimal digit (ranging from 0x0 to 0xF), depending on the positions of the four slide-switches assigned to them, respectively.
Additionally, the multiplexing was to occur so quickly that the change would be imperceptible to the human eye; in this case, the frequency chosen was 100 Hz, and was generated using the 48 MHz internal high-speed oscillator and a corresponding clock divider.
To achieve this more complicated arrangement, two transistors were integrated into the circuit to drive the large current required to fully power the 7-segment displays with the FPGA pins that would not necessarily be able to do so otherwise.
The sum of both hexadecimal digits at any given point in time was then communicated in binary across five green, externally-wired LEDs.

## Design and Testing Methodology
Overall, there were two inputs — including a reset (*reset*) and the eight slide-switches (*switch[7:0]*) — to the design and three outputs — that controlled the five LEDs (*led[4:0]*), each segment of the 7-segment displays (*segment[6:0]*), and the two transistors (*transistor[1:0]*), respectively.

As explained in [Lab 1](../lab1/lab1.qmd), the on-board high-speed oscillator, by default, produces a clock signal of 48 MHz.
By implementing a clock divider with a counter that would toggle one transistor on and the other off every time it reached 240,000 — because 48 MHz divided by the desired 100 Hz (as previously mentioned above) results in 480,000, and the toggling should take place twice a cycle (therefore dividing 480,000 by two to get 1240,000) — the time-multiplexing was able to occur at the correct frequency.
Note that the value of 100 Hz was chosen arbitrarily at first, before being deemed acceptable after observing the physical circuit in action and being unable to identify any noticeable delay and bleeding.

Regarding the 7-segment display design, as with [Lab 1](../lab1/lab1.qmd), each hexadecimal digit was intentionally designed to have a distinct appearance.
Because there were not enough FPGA pins to drive each segment individually across the two displays, there was simply one pin assigned to each *unique* pair of segments (for example, one pin would drive the bottom-left segments of both displays).
Thanks to the lab's multiplexing design, this was able to be done with no confusion as to which pins should be activated when.

Various tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later [Results and Discussions](#sec-results-and-discussion) section.
Note that there was an individual testbench created for each SystemVerilog module.

## Technical Documentation
The source code for this project can be found in the associated [GitHub repository folder](https://github.com/qmiyamoto/E155-Labs/tree/main/lab2).

### Block Diagram
![Block diagram of Verilog design](images/lab2_block_diagram.png){#fig-block-diagram}

The block diagram in [Figure 1](#fig-block-diagram) depicts the general architecture implied by the SystemVerilog code.
The top-level module, titled "*lab2_qm*," comprises a high-speed oscillator module that generates an *internal_oscillator* signal that supplies a clock for the following "*time_multiplexer*" module, which alternates the activation status of the two transistors.
That module is then followed by a mux, which chooses which set of four switch inputs to send to the "*seven_segment_display*" module and recreate hexadecimal digits, depending on the transistor that is on at the time; "*seven_segment_display*" can only handle four switch inputs at once, as it is an exact copy of the [Lab 1](../lab1/lab1.qmd) one's design.
Finally, the "*leds_sum*" module adds the two hexadecimal digits together and conveys the binary sum accordingly.

### Schematic
![Schematic of physical circuit](images/lab2_schematic.png){#fig-schematic}



The [Figure 2](#fig-schematic) schematic outlines how the physical components actually connect.
More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button, four slide-switches, three LEDs, and corresponding resistors of pre-determined 1 kΩ values — and the external MAN6460 7-segment display.
Note that the values of the resistors connected to the 7-segment display were calculated by doing the following computations in [Figure 3](#fig-resistor-math):



![7-segment display resistor math](){#fig-resistor-math width=60%}

In order to attain current draw that fell within the recommended operating conditions of 5 - 20 mA, Ohm's Law was applied to ultimately determine that any resistors ranging from 20 Ω to 240 Ω were acceptable to use.
For the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the [Figure 2](#fig-schematic) schematic.

## Results and Discussion {#sec-results-and-discussion}
The results of Lab 1 can be viewed in [Figure 4](#fig-video) below:

::: {#fig-video}
{{< video https://youtu.be/bY7URAfzgxI?feature=shared >}}

Demo Video
:::

### Testbench Simulation

::: {#fig-waveforms layout-ncol=3}
![Time multiplexer](images/time_multiplexer_waveforms_2.png){#fig-time-multiplexer-waveforms .lightbox}

![LEDs sum](images/leds_sum_waveforms_2.png){#fig-leds-sum-waveforms .lightbox}

![Top module](images/lab2_waveforms_2.png){#fig-lab2-waveforms .lightbox}

Simulation Waveforms
:::

![7-segment display](images/seven_segment_display_waveforms_2.png){#fig-seven-segment-display-waveforms .lightbox}

## Conclusion

A total of approximately 12 hours was spent working on this lab.

## AI Prototype
