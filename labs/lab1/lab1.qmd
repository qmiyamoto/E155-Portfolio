---
title: "Lab 1: FPGA and MCU Setup and Testing"
---

## Introduction {#sec-intro}
In this lab, the development board that will be used for the rest of the course was fully assembled, and the MCU and FPGA were respectively tested to ensure proper functionality.
The FPGA was then programmed with behavioral SystemVerilog code with the aim of blinking one on-board LED at a constant 2.4 Hz, using the internal high-frequency (48 MHz) oscillator, and two other on-board LEDs according to four slide-switch positions; more specifically, interpreting the expected relationship between the LEDs and switches (as outlined in the [Lab 1 instructions](https://hmc-e155.github.io/lab/lab1/#fpga-design)) as a truth table dictated that one would act as the output of a XOR gate, whereas the second would act as the output of an AND gate.
Additionally, a 7-segment display was interfaced with the those same four slide-switches, such that it was able to display hexadecimal digits 0x0 through 0xF.

## Design and Testing Methodology
Overall, there were three inputs — namely, ones corresponding to a clock (clk), a reset (reset), and the four switches (s[3:0]) — to the design, and two outputs that would control the respective states of the LEDs (led[2:0]) and segments (seg[6:0]).

The on-board high-speed oscillator, by default, produces a clock signal of 48 MHz.
By implementing a clock divider with a counter that would blink an on-board LED every time it reached 10,000,000 — because 48 MHz divided by the desired 2.4 Hz results in 20,000,000, and the LED should be flashed twice a cycle (therefore dividing 20,000,000 by two to get 10,000,000) — that signal was able to be reduced to the correct frequency.
Verilog code implying XOR and AND gates was also incorporated to connect the slide-switches and remaining two LEDs.

Regarding the 7-segment display design, each hexadecimal digit was intentionally designed to have a unique appearance.
This was reflected in the Verilog code via unique case statements with one toggle-able pin assigned to each segment.

Various tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later [Results and Discussions](#sec-results-and-discussion) section.
Note that there was an individual testbench created for each SystemVerilog module.

## Technical Documentation
The source code for this project can be found in the associated [GitHub repository folder](https://github.com/qmiyamoto/E155-Labs/tree/main/lab1).

### Block Diagram
![Block diagram of Verilog design](images/lab1_block_diagram.png){#fig-block-diagram}

The block diagram in [Figure 1](#fig-block-diagram) depicts the general architecture implied by the SystemVerilog code.
The top-level module, titled "lab1_qm," comprises two submodules, "on_board_leds" and "seven_segment_display" — the former for flashing the development board LEDs as detailed in the [Introduction](#sec-intro) above, and the latter for recreating hexadecimal digits on the 7-segment display.

### Schematic
![Schematic of physical circuit](images/lab1_schematic.png){#fig-schematic}

The [Figure 2](#fig-schematic) schematic outlines how the physical components actually connect.
More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button, four slide-switches, three LEDs, and corresponding resistors of pre-determined 1 kΩ values — and the external MAN6460 7-segment display.
Note that the values of the resistors connected to the 7-segment display were calculated by doing the following computations in [Figure 3](#fig-resistor-math):

![7-segment display resistor math](images/seven_segment_display_resistors_math.png){#fig-resistor-math width=60%}

In order to attain current draw that fell within the recommended operating conditions of 5 - 20 mA, Ohm's Law was applied to ultimately determine that any resistors ranging from 20 Ω to 240 Ω were acceptable to use.
For the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the [Figure 2](#fig-schematic) schematic.

## Results and Discussion {#sec-results-and-discussion}
The results of Lab 1 can be viewed in [Figure 4](#fig-video) below:

::: {#fig-video}
{{< video https://youtu.be/52ylZh-mB_w?feature=shared >}}

Demo Video
:::

Evidently, all prescribed tasks were successfully accomplished, and the design performed quickly and reliably.
Additionally, the oscilloscope trace from [Figure 5](#fig-oscope-trace) verified that one of the on-board LEDs did, in fact, flash at a constant rate of 2.4 Hz.

![Oscilloscope trace](images/oscilloscope_trace.jpg){#fig-oscope-trace}

### Testbench Simulation
::: {#fig-waveforms layout-ncol=3}
![On-board LEDs](images/on_board_leds_waveforms.png){#fig-on-board-leds-waveforms .lightbox}

![7-segment display](images/seven_segment_display_waveforms.png){#fig-seven-segment-display-waveforms .lightbox}

![Top module](images/lab1_waveforms.png){#fig-lab1-waveforms .lightbox}

Simulation Waveforms
:::

Moreover, the identical waveforms in [Figures 6a](#fig-on-board-leds-waveforms), [6b](#fig-seven-segment-display-waveforms), and [6c](#fig-lab1-waveforms), as well as the terminal output of the cumulative, top module tests depicted in [Figure 7](#fig-transcript), further prove that everything was working as intended.

![Top module transcript results](images/lab1_simulation_transcript.png){#fig-transcript}

## Conclusion
In summary, the design flashed one on-board LED at a consistent 2.4 Hz, and configured four slide-switches with two other LEDs to create a XOR gate and AND gate, respectively.
Furthermore, those same slide-switches successfully replicated every single hexadecimal digit on a 7-segment display, with each number sharing equal brightness.
A total of approximately 25 hours was spent working on this lab.

## AI Prototype
[Include generated code, easy-to-read chat transcripts, and a reflection on how well it worked.]

Write up a few paragraphs reflecting on your experience using the LLM to help you code. Feel free to make full use of screenshots, code snippets, and other media as you write your reflections.

Here are a few ideas of on what you might comment on:

How would you rate the quality of the output and why?
What SystemVerilog constructs/syntax did the LLM generated that were new to you?
Did the LLM-generated code synthesize the first time around? If not, what were the issues?
What error or warning messages did Radiant output?
What would you do differently the next time you use an LLM in your workflow?