[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Assembled the development board for the course and verified the MCU and FPGA’s respective functionalities. Programmed the FPGA with behavioral Verilog to blink on-board LEDs according to slide-switch positions and interface a 7-segment display, such that it would display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Labs",
    "section": "",
    "text": "Assembled the development board for the course and verified the MCU and FPGA’s respective functionalities. Programmed the FPGA with behavioral Verilog to blink on-board LEDs according to slide-switch positions and interface a 7-segment display, such that it would display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nImplemented a time-multiplexing scheme to switch between displaying hexadecimal digits 0x0 through 0xF on two separate 7-segment displays, at such a frequency that the switch would be imperceptible to the human eye. Utilized transistors to drive large currents from the FPGA pins to the two 7-segment displays. Interfaced the FPGA with five external LEDs, such that they would display the sum of the two hexadecimal digits at any given point in time."
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\n[Lab Overview]"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\n[Lab Overview]"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\n[Lab Overview]"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\n[Lab Overview]"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\n[Lab Overview]"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a time-multiplexer was implemented to switch between supplying power to two separate 7-segment displays, both of which were supposed to present a different hexadecimal digit (ranging from 0x0 to 0xF), depending on the positions of the four slide-switches assigned to them, respectively. Additionally, the multiplexing was to occur so quickly that the change would be imperceptible to the human eye; in this case, the frequency chosen was 100 Hz, and was generated using the 48 MHz internal high-speed oscillator and a corresponding clock divider. To achieve this more complicated arrangement, two transistors were integrated into the circuit to drive the large current required to fully power the 7-segment displays with the FPGA pins that would not necessarily be able to do so otherwise. The sum of both hexadecimal digits at any given point in time was then communicated in binary across five green, externally-wired LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#sec-intro",
    "href": "labs/lab2/lab2.html#sec-intro",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a time-multiplexer was implemented to switch between supplying power to two separate 7-segment displays, both of which were supposed to present a different hexadecimal digit (ranging from 0x0 to 0xF), depending on the positions of the four slide-switches assigned to them, respectively. Additionally, the multiplexing was to occur so quickly that the change would be imperceptible to the human eye; in this case, the frequency chosen was 100 Hz, and was generated using the 48 MHz internal high-speed oscillator and a corresponding clock divider. To achieve this more complicated arrangement, two transistors were integrated into the circuit to drive the large current required to fully power the 7-segment displays with the FPGA pins that would not necessarily be able to do so otherwise. The sum of both hexadecimal digits at any given point in time was then communicated in binary across five green, externally-wired LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOverall, there were two inputs — including a reset (reset) and the eight slide-switches (switch[7:0]) — to the design and three outputs — that controlled the five LEDs (led[4:0]), each segment of the 7-segment displays (segment[6:0]), and the two transistors (transistor[1:0]), respectively.\nAs explained in Lab 1, the on-board high-speed oscillator, by default, produces a clock signal of 48 MHz. By implementing a clock divider with a counter that would toggle one transistor on and the other off every time it reached 240,000 — because 48 MHz divided by the desired 100 Hz (as previously mentioned above) results in 480,000, and the toggling should take place twice a cycle (therefore dividing 480,000 by two to get 1240,000) — the time-multiplexing was able to occur at the correct frequency. Note that the value of 100 Hz was chosen arbitrarily at first, before being deemed acceptable after observing the physical circuit in action and being unable to identify any noticeable delay and bleeding.\nRegarding the 7-segment display design, as with Lab 1, each hexadecimal digit was intentionally designed to have a distinct appearance. Because there were not enough FPGA pins to drive each segment individually across the two displays, there was simply one pin assigned to each unique pair of segments (for example, one pin would drive the bottom-left segments of both displays). Thanks to the lab’s multiplexing design, this was able to be done with no confusion as to which pins should be activated when.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later Results and Discussions section. Note that there was an individual testbench created for each SystemVerilog module."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of Verilog design\n\n\n\nThe block diagram in Figure 1 depicts the general architecture implied by the SystemVerilog code. The top-level module, titled “lab2_qm,” comprises a high-speed oscillator module that generates an internal_oscillator signal that supplies a clock for the following “time_multiplexer” module, which alternates the activation status of the two transistors. That module is then followed by a mux, which chooses which set of four switch inputs to send to the “seven_segment_display” module and recreate hexadecimal digits, depending on the transistor that is on at the time; “seven_segment_display” can only handle four switch inputs at once, as it is an exact copy of the Lab 1 one’s design. Finally, the “leds_sum” module adds the two hexadecimal digits together and conveys the binary sum accordingly.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic of physical circuit\n\n\n\nThe Figure 2 schematic outlines how the physical components actually connect. More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button and four slide-switches — and the external MAN6410 7-segment displays, two 2N3906 PNP transistors, four additional slide-switches, five LEDs, and resistors of variable values.\nRegarding the latter, firstly, note that the values of the resistors connected to the two transistors and the two 7-segment displays, respectively, were picked after doing the computations depicted in Figure 3 below:\n\n\n\n\n\n\nFigure 3: PNP transistor and 7-segment display resistor math\n\n\n\nAs specified in section 4.17 of the ice40 datasheet for the FPGA, the current flowing into each GPIO pin should ideally be 8 mA at most. Thus, to justify the the particular resistors chosen, Ohm’s Law was applied to each part of the zoomed-in segment of the main circuit, clearly demonstrating that all current draw fell within recommended operating conditions. Ultimately, for the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the 7-segment display circuit, while both transistor bases received current-limiting resistors of 330 Ω. (Sources for the cited transistor information above comprise SparkFun Electronics and Glenn Lockwood. Additionally, the 7-segment display datasheet was used to find the forward voltage necessary to complete the correct calculations.)\nMoreover, the use of one 330 Ω-resistor per green LED can be rationalized via the following Figure 4:\n\n\n\n\n\n\nFigure 4: Green LED resistor math"
  },
  {
    "objectID": "labs/lab2/lab2.html#sec-results-and-discussion",
    "href": "labs/lab2/lab2.html#sec-results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 2 can be viewed in Figure 5 below:\n\n\n\n\n\n\nFigure 5: Demo video\n\n\n\nEvidently, all requirements were met. While the camera could detect some flickering that the naked human eye cannot perceive, it can still be conclusively said that the design was extremely effective.\n\nTestbench Simulation\n\n\n\n\n\n\n\n\n\n\n\n(a) Time multiplexer\n\n\n\n\n\n\n\n\n\n\n\n(b) LEDs sum\n\n\n\n\n\n\n\n\n\n\n\n(c) Top module\n\n\n\n\n\n\n\nFigure 6: Simulation waveforms\n\n\n\nThe waveforms in Figures 6a, 6b, and 6c further verify that the design was working exactly as intended; the time-multiplexing module toggles both transistors on and off at opposite times, the sums displayed across the LEDs always match the expected outcomes, and the top module hooks everything up to change with both the switch inputs and transistor activations as necessary.\nTo go more in depth about the top module waveforms, first note that the switch inputs are not changing at the exact same time as the transistors. This was intended to model more real-world behavior, in which someone would never realistically be moving the switches directly in sync with the rising edge of the internal clock. Furthermore, there is a small, indiscernible region around the 5,000,000 ns mark. This can be viewed more clearly in Figure 7 as follows:\n\n\n\n\n\n\nFigure 7: Top module waveforms, zoomed in\n\n\n\nAs can be observed in the Figure 1 block diagram, there was also a 7-segment display module used that — by proper verification standards — should have been simulated. It can be seen in Figure 8 below. Note that it is the exact same as the 7-segment display module used in Lab 1.\n\n\n\n\n\n\nFigure 8: 7-segment display\n\n\n\nAll testbenches and simulations passed without the presence of any error messages."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, the design toggled two 7-segment displays on and off at a constant 100 Hz with the help of transistors, such that they would always appear to depict two hexadecimal digits at once. These 7-segment displays were properly interfaced with four slide-switches each (for a total of eight slide-switches incorporated into the circuit overall), with the respective outputs dependent on the positions of said switches. Furthermore, the sum of both digits was consistently depicted in binary across five LEDs. A total of approximately 12 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits,” the LLM produced results that surprisingly synthesized; these can be viewed in the associated GitHub repository folder. Additionally, the full response can be seen in the public chat transcript.\nWhile the AI utilized a lot of unfamiliar code in its module, the general logic seemed to make sense. It used the same sort of counter-driven flip-flopped-toggle logic (see Figure 9) that was employed in the actual Lab 2 design to time-multiplex the two 7-segment displays, with a single set of case statements acting as a decoder, as requested.\n\n\n\n\n\n\nFigure 9: AI’s first attempt at multiplexing logic\n\n\n\nFurthermore, in response to the second prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files,” ChatGPT once again generated seemingly satisfactory results. The full response to this prompt can be seen in a second, entirely separate chat transcript.\nAs with its first response, this new code also contained new Verilog idioms, but still synthesized on the first try. Upon closer inspection, it once again appeared that the AI’s overall plan for tackling the prompt was correct. This time, it even provided a complementary top module for the code, albeit a somewhat unnecessary one, as shown in Figure 10 below:\n\n\n\n\n\n\nFigure 10: AI’s second attempt at creating a top module\n\n\n\nOverall, the quality of the output was acceptable, as it seemed to be mostly accurate after a cursory glance. In general, using an LLM to write the Lab 2 was genuinely helpful; it gave both a solid approach to solving the problem and code that did not generate any immediate errors in response to attempted implementation. However, in future projects for which LLM assistance is required, asking for additional, more explanatory comments as to what the employed Verilog idioms mean might make its answers even more useful."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Quinn Miyamoto is a junior engineering major at Harvey Mudd College. More specifically, she is interested in digital electronics and mechanical design. So far, she has completed courses pertaining to computer architecture, electricity and magnetism, and system-on-chip design. She has a Level Two CAD certification in Rhino, and works as a Makerspace steward for Harvey Mudd College, with a certification to teach users welding. When she is not working, you can find her reading manga/manhwa, binging bad Netflix shows, gaming, or rock-climbing."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflections\n\n\nMy first impressions of the course and subsequent goals for this semester!\n\n\n\n\n\nAug 26, 2025\n\n\nQuinn Miyamoto\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the development board that will be used for the rest of the course was fully assembled, and the MCU and FPGA were respectively tested to ensure proper functionality. The FPGA was then programmed with behavioral SystemVerilog code with the aim of blinking one on-board LED at a constant 2.4 Hz, using the internal high-frequency (48 MHz) oscillator, and two other on-board LEDs according to four slide-switch positions; more specifically, interpreting the expected relationship between the LEDs and switches (as outlined in the Lab 1 instructions) as a truth table dictated that one would act as the output of a XOR gate, whereas the second would act as the output of an AND gate. Additionally, a 7-segment display was interfaced with the those same four slide-switches, such that it was able to display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs/lab1/lab1.html#sec-intro",
    "href": "labs/lab1/lab1.html#sec-intro",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the development board that will be used for the rest of the course was fully assembled, and the MCU and FPGA were respectively tested to ensure proper functionality. The FPGA was then programmed with behavioral SystemVerilog code with the aim of blinking one on-board LED at a constant 2.4 Hz, using the internal high-frequency (48 MHz) oscillator, and two other on-board LEDs according to four slide-switch positions; more specifically, interpreting the expected relationship between the LEDs and switches (as outlined in the Lab 1 instructions) as a truth table dictated that one would act as the output of a XOR gate, whereas the second would act as the output of an AND gate. Additionally, a 7-segment display was interfaced with the those same four slide-switches, such that it was able to display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOverall, there were three inputs — namely, ones corresponding to a clock (clk), a reset (reset), and the four switches (s[3:0]) — to the design, and two outputs that would control the respective states of the LEDs (led[2:0]) and segments (seg[6:0]).\nThe on-board high-speed oscillator, by default, produces a clock signal of 48 MHz. By implementing a clock divider with a counter that would blink an on-board LED every time it reached 10,000,000 — because 48 MHz divided by the desired 2.4 Hz results in 20,000,000, and the LED should be flashed twice a cycle (therefore dividing 20,000,000 by two to get 10,000,000) — that signal was able to be reduced to the correct frequency. Verilog code implying XOR and AND gates was also incorporated to connect the slide-switches and remaining two LEDs.\nRegarding the 7-segment display design, each hexadecimal digit was intentionally designed to have a unique appearance. This was reflected in the Verilog code via unique case statements with one toggle-able pin assigned to each segment.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later Results and Discussions section. Note that there was an individual testbench created for each SystemVerilog module."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of Verilog design\n\n\n\nThe block diagram in Figure 1 depicts the general architecture implied by the SystemVerilog code. The top-level module, titled “lab1_qm,” comprises two submodules, “on_board_leds” and “seven_segment_display” — the former for flashing the development board LEDs as detailed in the Introduction above, and the latter for recreating hexadecimal digits on the 7-segment display.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic of physical circuit\n\n\n\nThe Figure 2 schematic outlines how the physical components actually connect. More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button, four slide-switches, three LEDs, and corresponding resistors of pre-determined 1 kΩ values — and the external MAN6460 7-segment display. Note that the values of the resistors connected to the 7-segment display were calculated by doing the following computations in Figure 3:\n\n\n\n\n\n\nFigure 3: 7-segment display resistor math\n\n\n\nIn order to attain current draw that fell within the recommended operating conditions of 5 - 20 mA, Ohm’s Law was applied to ultimately determine that any resistors ranging from 20 Ω to 240 Ω were acceptable to use. For the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the Figure 2 schematic."
  },
  {
    "objectID": "labs/lab1/lab1.html#sec-results-and-discussion",
    "href": "labs/lab1/lab1.html#sec-results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 1 can be viewed in Figure 4 below:\n\n\n\n\n\n\nFigure 4: Demo video\n\n\n\nEvidently, all prescribed tasks were successfully accomplished, and the design performed quickly and reliably. Additionally, the oscilloscope trace from Figure 5 verified that one of the on-board LEDs did, in fact, flash at a constant rate of 2.4 Hz.\n\n\n\n\n\n\nFigure 5: Oscilloscope trace\n\n\n\n\nTestbench Simulation\n\n\n\n\n\n\n\n\n\n\n\n(a) On-board LEDs\n\n\n\n\n\n\n\n\n\n\n\n(b) 7-segment display\n\n\n\n\n\n\n\n\n\n\n\n(c) Top module\n\n\n\n\n\n\n\nFigure 6: Simulation waveforms\n\n\n\nMoreover, the identical waveforms in Figures 6a, 6b, and 6c, as well as the terminal output of the cumulative, top module tests depicted in Figure 7, further prove that everything was working as intended.\n\n\n\n\n\n\nFigure 7: Top module transcript results"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, the design flashed one on-board LED at a consistent 2.4 Hz, and configured four slide-switches with two other LEDs to create a XOR gate and AND gate, respectively. Furthermore, those same slide-switches successfully replicated every single hexadecimal digit on a 7-segment display, with each number sharing equal brightness. A total of approximately 25 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg,” the LLM ultimately produced inaccurate results that were unable to be synthesized; these can be viewed in the associated GitHub repository folder. While at first glance, the instructions in the chat transcript seemed rather straightforward and clear, when actually attempting to implement them in Lattice, there were many errors that popped up. After three tries at steering the LLM’s responses toward more accurate, desirable outcomes, all attempts at further guiding stopped.\n\n\n\n\n\n\nFigure 8: First error message\n\n\n\nThe first error message received, as shown in Figure 8, concerned the missing iCE40UP primitive library file that was necessary for utilizing the SB_HFOSC module (in order to work with the development board’s high-frequency oscillator). This was addressed by taking ChatGPT’s “alternative workaround” recommendation to add an ifndef SYNTHESIS wrapper to the SB_HFOSC code to synthesize without adding extra files to the simulation. Unfortunately, while doing this did indeed get rid of the initial error, it led to the generation of another one.\n\n\n\n\n\n\nFigure 9: Second error message\n\n\n\nFigure 9 depicts an error message pertaining to a “synthesis-time combinational loop error,” according to CHatGPT, which would supposedly be solved by re-checking the inclusion of the iCE40UP library and keeping ports tied correctly. However, this time, adhering to its directions did not have any effect on the synthesis.\n\n\n\n\n\n\nFigure 10: Third error message\n\n\n\nThe last error message to appear, as can be viewed in Figure 10 above, was the exact same as the one from Figure 9. At this point, ChatGPT presented the same solution for a third time, and was subsequently sidelined in favor of manually reviewing its code to fix things up.\nIn general, using an LLM to write the Lab 1 code was helpful to a certain extent; ChatGPT gave a rather good outline of what should be done to blink an LED at 2 Hz. However, when it came to the fine details that were crucial for making the code work, it tended to falter in supplying both adequate code and sufficient instructions for how to remedy any lapses in judgement. Therefore, the quality of the output was solidly middling.\nPerhaps the most notable feature of the LLM’s code was its usage of the SB_HFOSC module, which was extremely similar to the HSOSC one actual utilized for the lab (as briefly talked about above). In the future, if LLM assistance is ever required by a project, more care will be taken to understand the constructs/syntax it employs so as to prompt it to give better, more effective answers."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflections",
    "section": "",
    "text": "After briefly skimming over the content of our future labs, I am already extremely excited for the semester to come! As someone who wants to specialize in, essentially, ECE (with a little side of mechanical engineering to boot!), this is the perfect course for me; it seems to cover a good amount of the overlap between programming and actual hardware development, which I have always wanted to dive more into. Because I did rather poorly on the exams in E85, I am admittedly also a little nervous for this course’s rigor. However, seeing as E155’s learning is not test-based in the slightest, I do not feel as stressed out about my performance as I could be.\nAt the moment, I do not have any particular ideas in mind for the final project. If possible, I would like to do something that involves working with LEDs (or other lights), for I find such projects satisfyingly aesthetic and fun, but I am not too picky on the content beyond that. I have faith that no matter what, it will be a challenging but ultimately rewarding experience for me.\nMy goals for this semester comprise the following: stay on top of my work, make the most of the resources available to me (including grutors and professors), create a final project that I can be proud of, and maintain an open and positive mindset, even when times get hard. While I would naturally like to succeed academically in this class, I believe that these more soft skill-oriented objectives are just as - if not more - important than attaining good grades. Overall, I hope to come out of this course as both a better engineer and person."
  }
]