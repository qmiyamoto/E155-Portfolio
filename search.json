[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Assembled the development board for the course and verified the MCU and FPGA’s respective functionalities. Programmed the FPGA with behavioral Verilog to blink on-board LEDs according to slide-switch positions and interface a 7-segment display, such that it would display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Labs",
    "section": "",
    "text": "Assembled the development board for the course and verified the MCU and FPGA’s respective functionalities. Programmed the FPGA with behavioral Verilog to blink on-board LEDs according to slide-switch positions and interface a 7-segment display, such that it would display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nImplemented a time-multiplexing scheme to switch between displaying hexadecimal digits 0x0 through 0xF on two separate 7-segment displays, at such a frequency that the switch would be imperceptible to the human eye. Utilized transistors to drive large currents from the FPGA pins to the two 7-segment displays. Interfaced the FPGA with five external LEDs, such that they would display the sum of the two hexadecimal digits at any given point in time."
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nDesigned and implemented a circuit to interface the FPGA with a 4x4 matrix keypad, such that it would accurately read the pressed buttons and subsequently output the two most recent digits on two 7-segment displays. Effectively dealt with switch bouncing. Ensured that any combination of asynchronous user inputs — including, but not limited to, pressing multiple buttons at once and holding buttons for extended periods of time — did not result in erratic, undesirable behavior."
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nBuilt a circuit to drive a speaker with the development board’s MCU — via GPIO pin toggling — and ultimately play music. Wrote own C libraries from scratch to enable and interface the MCU clock and timers. Generated square waves of specified frequencies for specified durations with the MCU timers."
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nImplemented a multi-interrupt routine on the MCU to detect pulses from a given motor’s quadrature encoder and convert that information into a value for angular velocity. Used the built-in Debug mode in Segger to display said motor velocity and direction in the terminal, with an update rate of at least 1 Hz."
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\nInterfaced the MCU with both a DS1722 temperature sensor and an ESP8266 WiFi development board using the SPI and UART peripherals, respectively, in order to build a simple Internet of Things device. Programmed a simple HTML webpage to display the temperature (in Celsius) recorded by the DS1722 sensor — with this value updating every time the site is refreshed — allow a user to set its resolution by hand (to any integer value between eight and 12), toggle an on-board LED, and display the status of said LED accordingly. Used an oscilloscope’s Logic Analyzer function to capture proof of proper SPI transactions occurring."
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\n[Lab Overview]"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, the MCU was interfaced with both a DS1722 temperature sensor and an ESP8266 WiFi development board in order to display the output of the former (in Celsius) on a webpage, with the information updating every time the site was refreshed. Additionally, interaction with the page’s buttons allowed the user to manually set the sensor’s resolution to any integer value between eight and 12, as well as toggle an on-board LED and report its status accordingly. Thus, in brief, the aim of this assignment was to design and create an Internet of Things device. Furthermore, the Logic Analyzer function on one of the lab oscilloscopes was used to prove that proper SPI transactions were actually occurring."
  },
  {
    "objectID": "labs/lab6/lab6.html#sec-intro",
    "href": "labs/lab6/lab6.html#sec-intro",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, the MCU was interfaced with both a DS1722 temperature sensor and an ESP8266 WiFi development board in order to display the output of the former (in Celsius) on a webpage, with the information updating every time the site was refreshed. Additionally, interaction with the page’s buttons allowed the user to manually set the sensor’s resolution to any integer value between eight and 12, as well as toggle an on-board LED and report its status accordingly. Thus, in brief, the aim of this assignment was to design and create an Internet of Things device. Furthermore, the Logic Analyzer function on one of the lab oscilloscopes was used to prove that proper SPI transactions were actually occurring."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-and-testing-methodology",
    "href": "labs/lab6/lab6.html#design-and-testing-methodology",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFirstly, the MCU’s SPI peripheral was configured to allow communication with the temperature sensor, with the MCU as the controller and the temperature sensor as the peripheral. Following the configuration guidelines/restrictions outlined in the sensor’s datasheet baud rate of 5 MHz, clock polarity of zero (corresponding to an idle clock signal of zero, according to the MCU’s own reference manual), and a clock phase of one (which set the first data capture edge to the clock’s second transition). Moreover, the sensor was set to continuously poll. Pins PB0 and PB3 were used to output the chip select and clock signals, respectively, while the SDO and SDI signals were tied to PB4 and PB5.\nNext, the UART/USART protocol was enabled to talk to the ESP8266 unit. All of the webpage’s contents were written in HTML and sent from the MCU to the WiFi development device by tying the former’s receiver pin, PA9, to the latter’s TX and the transmitter pin PA10 to RX. Finally, PA6 was configured as the toggle-able on-board LED. (Note that some files were not originally produced and were instead taken from the starter code provided by the teaching team.)\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuit and oscilloscope traces, as elaborated on in a later Results and Discussion section."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of physical circuit\n\n\n\nThe Figure 1 schematic outlines how the physical components actually connect. Note that the temperature sensor’s SERMODE, which sets the serial interface mode through hardware, was hooked up to power in order to enable SPI communication (as opposed to a standard 3-wire data transfer). All SPI-related pins were chosen from GPIO Port B’s selection so that they would not interfere with the UART/USART pins tied to GPIO Port A."
  },
  {
    "objectID": "labs/lab6/lab6.html#sec-results-and-discussion",
    "href": "labs/lab6/lab6.html#sec-results-and-discussion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 6 are shown in Figure 2, as follows:\n\n\n\n\n\n\nFigure 2: Demo video\n\n\n\nAs can clearly be seen in the video above, the design performs well and meets all of the required specs; in response to heat being applied to the temperature sensor via someone’s finger, the website displayed reasonable results with appropriate incrementing. However, one point of improvement would be to mitigate the need to click twice on a given resolution button in order to actually receive the desired temperature reading.\n\nE155 Online LED Toggler and Temperature Reporter Webpage\n\n\n\n\n\n\nFigure 3: Webpage\n\n\n\nThe screenshot depicted in Figure 3 provides an example of what the actual webpage, hosted at 192.168.4.1, would look like if the “LED: Off” and “Resolution: 12” buttons were pressed. Note that resolutions eight through twelve correspond to actual temperature resolutions of 1.0 °C, 0.5 °C, 0.25 °C, 0.125 °C, and 0.0625 °C, respectively.\n\n\nLogic Analyzer Traces\n\n\n\n\n\n\n\n\n\n\n\n(a) SPI Write transaction\n\n\n\n\n\n\n\n\n\n\n\n(b) SPI Read transaction\n\n\n\n\n\n\n\nFigure 4: Logic Analyzer traces on the oscilloscope\n\n\n\nIn order to verify that the MCU and temperature sensor were interfacing over SPI as intended, the oscilloscope’s Logic Analyzer function was used to capture the states of the SCLK, MISO (SDO), and MOSI (SDI) signals during a single pulse of the CE signal. Figure 4a shows the MCU first forcing the sensor into Write mode with the 0x80 address before immediately telling it to set a 12-bit resolution with 0xEE, while Figure 4b depicts the sensor entering Read mode twice — with both the 0x02 and 0x01 addresses — to fetch the information stored in both the MSB and LSB. All in all, the appearance of the expected addresses being sent over SDO and SDI evidences the existence of proper SPI communication."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, the design used both the SPI and UART/USART protocols to enable communication between the MCU, temperature sensor, and WiFi development board, and successfully displayed a live, updatable report of the temperature with user-adjustable resolution online, along with the status of an on-board LED. A total of approximately 12 hours was spent on this lab."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype",
    "href": "labs/lab6/lab6.html#ai-prototype",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype",
    "text": "AI Prototype"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, a speaker was made to play music by toggling a GPIO pin at user-specified frequencies with the on-board MCU. More specifically, various C libraries were written from scratch so as to ultimately allow for interfacing between the MCU’s internal clock and timers. After taking in a system clock input of 80 MHz (the maximum possible PLL output frequency) and dividing it as necessary, one of the timers was used to generate square waves of variable frequencies, while another prolonged the existence of said square waves for specific periods of time. In other words: The first timer controlled the pitch of the song notes, while the other controlled the note durations. Additionally, a potentiometer was integrated into the MCU-speaker circuit to allow for user-dictated volume control."
  },
  {
    "objectID": "labs/lab4/lab4.html#sec-intro",
    "href": "labs/lab4/lab4.html#sec-intro",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab, a speaker was made to play music by toggling a GPIO pin at user-specified frequencies with the on-board MCU. More specifically, various C libraries were written from scratch so as to ultimately allow for interfacing between the MCU’s internal clock and timers. After taking in a system clock input of 80 MHz (the maximum possible PLL output frequency) and dividing it as necessary, one of the timers was used to generate square waves of variable frequencies, while another prolonged the existence of said square waves for specific periods of time. In other words: The first timer controlled the pitch of the song notes, while the other controlled the note durations. Additionally, a potentiometer was integrated into the MCU-speaker circuit to allow for user-dictated volume control."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4: Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFirstly, the PLL was configured to take in the multispeed internal (MSI) RC oscillator as an input and output an 80 MHz clock signal. Then, timers TIM16 and TIM15 were set up to generate the PWM and mandate its duration, respectively. Finally, GPIO pin PA6 was chosen to actually output the square waves and interface with the physical world. (Note that some files were not originally produced and were instead taken from the solutions branch of an in-class activity.)\nThe two songs that the MCU was programmed to play were 1) Für Elise, as given in some Lab 4 starter code, and 2) Legendary; the sheet music for the latter was found online and was subsequently transcribed into more beginner-friendly notation by Alan Kappler.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuit and oscilloscope traces, as elaborated on in a later Results and Discussion section."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of physical circuit\n\n\n\nThe Figure 1 schematic outlines how the physical components actually connect. All capacitor and resistor values were taken from an example circuit provided in the LM386 audio amplifier datasheet (specifically Figure 9-5, which depicts the LM386 with a gain of 50).\n\n\nMinimum and Maximum Supported Frequencies and Durations\nAdditionally, the minimum and maximum possible frequencies and durations supported with the current prescaler values — what the internal system clock is ultimately divided by for the timer’s convenience — used in the code can be viewed in the following Figures 2a and 2b.\n\n\n\n\n\n\n\n\n\n\n\n(a) Frequencies\n\n\n\n\n\n\n\n\n\n\n\n(b) Durations\n\n\n\n\n\n\n\nFigure 2: Calculations for minimum and maximum values\n\n\n\nThese computations were all performed with equations given in the STM32L432KC MCU reference manual. Most notably, the ARR value was relevant to all calculations because of the fact that it was the maximum number that any given timer could count up to before triggering an Update Interrupt Flag and exiting the C function."
  },
  {
    "objectID": "labs/lab4/lab4.html#sec-results-and-discussion",
    "href": "labs/lab4/lab4.html#sec-results-and-discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 4 can be viewed in Figures 3a and 3b below:\n\n\n\n\n\n\n\n\n\n\n\n(a) Für Elise\n\n\n\n\n\n\n\n\n\n\n\n(b) Legendary\n\n\n\n\n\n\n\nFigure 3: Demo videos\n\n\n\nEvidently, all of the Lab 4 specs were met; all of the notes were the correct pitches and lasted for the appropriate durations. Although the specific potentiometer used didn’t allow for the finest volume control possible, it still worked well enough that it was deemed acceptable to keep.\n\nOscilloscope Traces\n\n\n\n\n\n\n\n\n\n\n\n(a) First note\n\n\n\n\n\n\n\n\n\n\n\n(b) Second note\n\n\n\n\n\n\n\nFigure 4: Für Elise oscilloscope traces\n\n\n\nIn order to verify that the speaker was outputting the correct pitches as intended, an oscilloscope was used to determine the actual frequencies being played for the first two notes of Für Elise. When compared to the expected values of 659 and 623 Hz, respectively, it was suffice to say that the design did, in fact, perform rather accurately.\nFurthermore, to really prove that the choice of the design was, without a doubt, completely functional, the speaker was forced to play both 200 and 1000 Hz signals — the bounds of an appropriately large frequency range, according to the specs — with the corresponding oscilloscope traces pictured in Figures 5a and 5b as follows:\n\n\n\n\n\n\n\n\n\n\n\n(a) 200 Hz\n\n\n\n\n\n\n\n\n\n\n\n(b) 1000 Hz\n\n\n\n\n\n\n\nFigure 5: Oscilloscope traces for the required frequency range bounds\n\n\n\nFinally, a few mathematical computations were performed in Figure 6 to quantify just how much percent error the actual output comprised when compared to theoretical results, and ultimately show that none of these values for the 200 to 1000 Hz frequency range were greater than one percent, as desired:\n\n\n\n\n\n\nFigure 6: Accuracy verification calculations"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, the design played both Für Elise and a composition of choice (Legendary) as required, with all notes having pitches and durations that were accurate to within one percent of the intended outcomes for the range of 200 to 1000 Hz. Additionally, a potentiometer was successfully incorporated into the circuit so as to allow for volume control. A total of approximately 15 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype",
    "href": "labs/lab4/lab4.html#ai-prototype",
    "title": "Lab 4: Digital Audio",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?,” the LLM produced surprisingly accurate results that can be viewed in the public chat transcript.\nMost notably, the AI was correct in its timer overview (as depicted in Figure 7), with the recommended general purpose timers TIM15 and TIM16 being exactly what was used in the actual lab above.\n\n\n\n\n\n\nFigure 7: Available timers\n\n\n\nFurthermore, the provided formulae for both the note frequency and the duty cycle calculations were surprisingly correct. These are shown in Figure 8 below. The only things that were missing were the equations for ARR when trying to prolong the duration of a note.\n\n\n\n\n\n\nFigure 8: Formulae\n\n\n\nThe LLM was also pretty accurate when it came to listing registers that needed to be configured, as seen in Figure 9. All of the registers it suggested were, in fact, necessary to consider; however, it did omit a few crucial ones. For instance, the Update Generation bit in the Event Generation Register was also rather important to set, as well as the SMS bits in the SMCR.\n\n\n\n\n\n\nFigure 9: AI-recommended registers\n\n\n\nAll in all, the quality of the output this time was extremely good, for it did not comprise any obvious inaccuracies. If the LLM-user was to approach this response with the mindset that it would provide a solid starting point but not everything that needed to be considered, it could prove to be invaluable help. The AI was definitely able to parse the reference manual at a far greater speed than any human could; it was even better at providing guidance than Ctrl-F (which, due to the sheer size of the manual, often missed things on not-yet-loaded pages)."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a time-multiplexer was implemented to switch between supplying power to two separate 7-segment displays, both of which were supposed to present a different hexadecimal digit (ranging from 0x0 to 0xF), depending on the positions of the four slide-switches assigned to them, respectively. Additionally, the multiplexing was to occur so quickly that the change would be imperceptible to the human eye; in this case, the frequency chosen was 100 Hz, and was generated using the 48 MHz internal high-speed oscillator and a corresponding clock divider. To achieve this more complicated arrangement, two transistors were integrated into the circuit to drive the large current required to fully power the 7-segment displays with the FPGA pins that would not necessarily be able to do so otherwise. The sum of both hexadecimal digits at any given point in time was then communicated in binary across five green, externally-wired LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#sec-intro",
    "href": "labs/lab2/lab2.html#sec-intro",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab, a time-multiplexer was implemented to switch between supplying power to two separate 7-segment displays, both of which were supposed to present a different hexadecimal digit (ranging from 0x0 to 0xF), depending on the positions of the four slide-switches assigned to them, respectively. Additionally, the multiplexing was to occur so quickly that the change would be imperceptible to the human eye; in this case, the frequency chosen was 100 Hz, and was generated using the 48 MHz internal high-speed oscillator and a corresponding clock divider. To achieve this more complicated arrangement, two transistors were integrated into the circuit to drive the large current required to fully power the 7-segment displays with the FPGA pins that would not necessarily be able to do so otherwise. The sum of both hexadecimal digits at any given point in time was then communicated in binary across five green, externally-wired LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOverall, there were two inputs — including a reset (reset) and the eight slide-switches (switch[7:0]) — to the design and three outputs — that controlled the five LEDs (led[4:0]), each segment of the 7-segment displays (segment[6:0]), and the two transistors (transistor[1:0]), respectively.\nAs explained in Lab 1, the on-board high-speed oscillator, by default, produces a clock signal of 48 MHz. By implementing a clock divider with a counter that would toggle one transistor on and the other off every time it reached 240,000 — because 48 MHz divided by the desired 100 Hz (as previously mentioned above) results in 480,000, and the toggling should take place twice a cycle (therefore dividing 480,000 by two to get 1240,000) — the time-multiplexing was able to occur at the correct frequency. Note that the value of 100 Hz was chosen arbitrarily at first, before being deemed acceptable after observing the physical circuit in action and being unable to identify any noticeable delay and bleeding.\nRegarding the 7-segment display design, as with Lab 1, each hexadecimal digit was intentionally designed to have a distinct appearance. Because there were not enough FPGA pins to drive each segment individually across the two displays, there was simply one pin assigned to each unique pair of segments (for example, one pin would drive the bottom-left segments of both displays). Thanks to the lab’s multiplexing design, this was able to be done with no confusion as to which pins should be activated when.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later Results and Discussion section. Note that there was an individual testbench created for each SystemVerilog module."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of Verilog design\n\n\n\nThe block diagram in Figure 1 depicts the general architecture implied by the SystemVerilog code. The top-level module, titled “lab2_qm,” comprises a high-speed oscillator module that generates an internal_oscillator signal that supplies a clock for the following “time_multiplexer” module, which alternates the activation status of the two transistors. That module is then followed by a mux, which chooses which set of four switch inputs to send to the “seven_segment_display” module and recreate hexadecimal digits, depending on the transistor that is on at the time; “seven_segment_display” can only handle four switch inputs at once, as it is an exact copy of the Lab 1 one’s design. Finally, the “leds_sum” module adds the two hexadecimal digits together and conveys the binary sum accordingly.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic of physical circuit\n\n\n\nThe Figure 2 schematic outlines how the physical components actually connect. More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button and four slide-switches — and the external MAN6410 7-segment displays, two 2N3906 PNP transistors, four additional slide-switches, five LEDs, and resistors of variable values.\nRegarding the latter, firstly, note that the values of the resistors connected to the two transistors and the two 7-segment displays, respectively, were picked after doing the computations depicted in Figure 3 below:\n\n\n\n\n\n\nFigure 3: PNP transistor and 7-segment display resistor math\n\n\n\nAs specified in section 4.17 of the ice40 datasheet for the FPGA, the current flowing into each GPIO pin should ideally be 8 mA at most. Thus, to justify the the particular resistors chosen, Ohm’s Law was applied to each part of the zoomed-in segment of the main circuit, clearly demonstrating that all current draw fell within recommended operating conditions. Ultimately, for the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the 7-segment display circuit, while both transistor bases received current-limiting resistors of 330 Ω. (Sources for the cited transistor information above comprise SparkFun Electronics and Glenn Lockwood. Additionally, the 7-segment display datasheet was used to find the forward voltage necessary to complete the correct calculations.)\nMoreover, the use of one 330 Ω-resistor per green LED can be rationalized via the following Figure 4:\n\n\n\n\n\n\nFigure 4: Green LED resistor math"
  },
  {
    "objectID": "labs/lab2/lab2.html#sec-results-and-discussion",
    "href": "labs/lab2/lab2.html#sec-results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 2 can be viewed in Figure 5 below:\n\n\n\n\n\n\nFigure 5: Demo video\n\n\n\nEvidently, all requirements were met. While the camera could detect some flickering that the naked human eye cannot perceive, it can still be conclusively said that the design was extremely effective.\n\nTestbench Simulation\n\n\n\n\n\n\n\n\n\n\n\n(a) Time multiplexer\n\n\n\n\n\n\n\n\n\n\n\n(b) LEDs sum\n\n\n\n\n\n\n\n\n\n\n\n(c) Top module\n\n\n\n\n\n\n\nFigure 6: Simulation waveforms\n\n\n\nThe waveforms in Figures 6a, 6b, and 6c further verify that the design was working exactly as intended; the time-multiplexing module toggles both transistors on and off at opposite times, the sums displayed across the LEDs always match the expected outcomes, and the top module hooks everything up to change with both the switch inputs and transistor activations as necessary.\nTo go more in depth about the top module waveforms, first note that the switch inputs are not changing at the exact same time as the transistors. This was intended to model more real-world behavior, in which someone would never realistically be moving the switches directly in sync with the rising edge of the internal clock. Furthermore, there is a small, indiscernible region around the 5,000,000 ns mark. This can be viewed more clearly in Figure 7 as follows:\n\n\n\n\n\n\nFigure 7: Top module waveforms, zoomed in\n\n\n\nAs can be observed in the Figure 1 block diagram, there was also a 7-segment display module used that — by proper verification standards — should have been simulated. It can be seen in Figure 8 below. Note that it is the exact same as the 7-segment display module used in Lab 1.\n\n\n\n\n\n\nFigure 8: 7-segment display\n\n\n\nAll testbenches and simulations passed without the presence of any error messages."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, the design toggled two 7-segment displays on and off at a constant 100 Hz with the help of transistors, such that they would always appear to depict two hexadecimal digits at once. These 7-segment displays were properly interfaced with four slide-switches each (for a total of eight slide-switches incorporated into the circuit overall), with the respective outputs dependent on the positions of said switches. Furthermore, the sum of both digits was consistently depicted in binary across five LEDs. A total of approximately 12 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits,” the LLM produced results that surprisingly synthesized; these can be viewed in the associated GitHub repository folder. Additionally, the full response can be seen in the public chat transcript.\nWhile the AI utilized a lot of unfamiliar code in its module, the general logic seemed to make sense. It used the same sort of counter-driven flip-flopped-toggle logic (see Figure 9) that was employed in the actual Lab 2 design to time-multiplex the two 7-segment displays, with a single set of case statements acting as a decoder, as requested.\n\n\n\n\n\n\nFigure 9: AI’s first attempt at multiplexing logic\n\n\n\nFurthermore, in response to the second prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files,” ChatGPT once again generated seemingly satisfactory results. The full response to this prompt can be seen in a second, entirely separate chat transcript.\nAs with its first response, this new code also contained new Verilog idioms, but still synthesized on the first try. Upon closer inspection, it once again appeared that the AI’s overall plan for tackling the prompt was correct. This time, it even provided a complementary top module for the code, albeit a somewhat unnecessary one, as shown in Figure 10 below:\n\n\n\n\n\n\nFigure 10: AI’s second attempt at creating a top module\n\n\n\nOverall, the quality of the output was acceptable, as it seemed to be mostly accurate after a cursory glance. In general, using an LLM to write the Lab 2 was genuinely helpful; it gave both a solid approach to solving the problem and code that did not generate any immediate errors in response to attempted implementation. However, in future projects for which LLM assistance is required, asking for additional, more explanatory comments as to what the employed Verilog idioms mean might make its answers even more useful."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Quinn Miyamoto is a junior engineering major at Harvey Mudd College. More specifically, she is interested in digital electronics and mechanical design. So far, she has completed courses pertaining to computer architecture, electricity and magnetism, and system-on-chip design. She has a Level Two CAD certification in Rhino, and works as a Makerspace steward for Harvey Mudd College, with a certification to teach users welding. When she is not working, you can find her reading manga/manhwa, binging bad Netflix shows, gaming, or rock-climbing."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflections\n\n\nMy first impressions of the course and subsequent goals for this semester!\n\n\n\n\n\nAug 26, 2025\n\n\nQuinn Miyamoto\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the development board that will be used for the rest of the course was fully assembled, and the MCU and FPGA were respectively tested to ensure proper functionality. The FPGA was then programmed with behavioral SystemVerilog code with the aim of blinking one on-board LED at a constant 2.4 Hz, using the internal high-frequency (48 MHz) oscillator, and two other on-board LEDs according to four slide-switch positions; more specifically, interpreting the expected relationship between the LEDs and switches (as outlined in the Lab 1 instructions) as a truth table dictated that one would act as the output of a XOR gate, whereas the second would act as the output of an AND gate. Additionally, a 7-segment display was interfaced with the those same four slide-switches, such that it was able to display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs/lab1/lab1.html#sec-intro",
    "href": "labs/lab1/lab1.html#sec-intro",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the development board that will be used for the rest of the course was fully assembled, and the MCU and FPGA were respectively tested to ensure proper functionality. The FPGA was then programmed with behavioral SystemVerilog code with the aim of blinking one on-board LED at a constant 2.4 Hz, using the internal high-frequency (48 MHz) oscillator, and two other on-board LEDs according to four slide-switch positions; more specifically, interpreting the expected relationship between the LEDs and switches (as outlined in the Lab 1 instructions) as a truth table dictated that one would act as the output of a XOR gate, whereas the second would act as the output of an AND gate. Additionally, a 7-segment display was interfaced with the those same four slide-switches, such that it was able to display hexadecimal digits 0x0 through 0xF."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOverall, there were three inputs — namely, ones corresponding to a clock (clk), a reset (reset), and the four switches (s[3:0]) — to the design, and two outputs that would control the respective states of the LEDs (led[2:0]) and segments (seg[6:0]).\nThe on-board high-speed oscillator, by default, produces a clock signal of 48 MHz. By implementing a clock divider with a counter that would blink an on-board LED every time it reached 10,000,000 — because 48 MHz divided by the desired 2.4 Hz results in 20,000,000, and the LED should be flashed twice a cycle (therefore dividing 20,000,000 by two to get 10,000,000) — that signal was able to be reduced to the correct frequency. Verilog code implying XOR and AND gates was also incorporated to connect the slide-switches and remaining two LEDs.\nRegarding the 7-segment display design, each hexadecimal digit was intentionally designed to have a unique appearance. This was reflected in the Verilog code via unique case statements with one toggle-able pin assigned to each segment.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later Results and Discussion section. Note that there was an individual testbench created for each SystemVerilog module."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of Verilog design\n\n\n\nThe block diagram in Figure 1 depicts the general architecture implied by the SystemVerilog code. The top-level module, titled “lab1_qm,” comprises two submodules, “on_board_leds” and “seven_segment_display” — the former for flashing the development board LEDs as detailed in the Introduction above, and the latter for recreating hexadecimal digits on the 7-segment display.\n\n\nSchematic\n\n\n\n\n\n\nFigure 2: Schematic of physical circuit\n\n\n\nThe Figure 2 schematic outlines how the physical components actually connect. More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from both the on-board elements — including a push-button, four slide-switches, three LEDs, and corresponding resistors of pre-determined 1 kΩ values — and the external MAN6460 7-segment display. Note that the values of the resistors connected to the 7-segment display were calculated by doing the following computations in Figure 3:\n\n\n\n\n\n\nFigure 3: 7-segment display resistor math\n\n\n\nIn order to attain current draw that fell within the recommended operating conditions of 5 - 20 mA, Ohm’s Law was applied to ultimately determine that any resistors ranging from 20 Ω to 240 Ω were acceptable to use. For the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the Figure 2 schematic."
  },
  {
    "objectID": "labs/lab1/lab1.html#sec-results-and-discussion",
    "href": "labs/lab1/lab1.html#sec-results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 1 can be viewed in Figure 4 below:\n\n\n\n\n\n\nFigure 4: Demo video\n\n\n\nEvidently, all prescribed tasks were successfully accomplished, and the design performed quickly and reliably. Additionally, the oscilloscope trace from Figure 5 verified that one of the on-board LEDs did, in fact, flash at a constant rate of 2.4 Hz.\n\n\n\n\n\n\nFigure 5: Oscilloscope trace\n\n\n\n\nTestbench Simulation\n\n\n\n\n\n\n\n\n\n\n\n(a) On-board LEDs\n\n\n\n\n\n\n\n\n\n\n\n(b) 7-segment display\n\n\n\n\n\n\n\n\n\n\n\n(c) Top module\n\n\n\n\n\n\n\nFigure 6: Simulation waveforms\n\n\n\nMoreover, the identical waveforms in Figures 6a, 6b, and 6c, as well as the terminal output of the cumulative, top module tests depicted in Figure 7, further prove that everything was working as intended.\n\n\n\n\n\n\nFigure 7: Top module transcript results"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, the design flashed one on-board LED at a consistent 2.4 Hz, and configured four slide-switches with two other LEDs to create a XOR gate and AND gate, respectively. Furthermore, those same slide-switches successfully replicated every single hexadecimal digit on a 7-segment display, with each number sharing equal brightness. A total of approximately 25 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg,” the LLM ultimately produced inaccurate results that were unable to be synthesized; these can be viewed in the associated GitHub repository folder. While at first glance, the instructions in the chat transcript seemed rather straightforward and clear, when actually attempting to implement them in Lattice, there were many errors that popped up. After three tries at steering the LLM’s responses toward more accurate, desirable outcomes, all attempts at further guiding stopped.\n\n\n\n\n\n\nFigure 8: First error message\n\n\n\nThe first error message received, as shown in Figure 8, concerned the missing iCE40UP primitive library file that was necessary for utilizing the SB_HFOSC module (in order to work with the development board’s high-frequency oscillator). This was addressed by taking ChatGPT’s “alternative workaround” recommendation to add an ifndef SYNTHESIS wrapper to the SB_HFOSC code to synthesize without adding extra files to the simulation. Unfortunately, while doing this did indeed get rid of the initial error, it led to the generation of another one.\n\n\n\n\n\n\nFigure 9: Second error message\n\n\n\nFigure 9 depicts an error message pertaining to a “synthesis-time combinational loop error,” according to CHatGPT, which would supposedly be solved by re-checking the inclusion of the iCE40UP library and keeping ports tied correctly. However, this time, adhering to its directions did not have any effect on the synthesis.\n\n\n\n\n\n\nFigure 10: Third error message\n\n\n\nThe last error message to appear, as can be viewed in Figure 10 above, was the exact same as the one from Figure 9. At this point, ChatGPT presented the same solution for a third time, and was subsequently sidelined in favor of manually reviewing its code to fix things up.\nIn general, using an LLM to write the Lab 1 code was helpful to a certain extent; ChatGPT gave a rather good outline of what should be done to blink an LED at 2 Hz. However, when it came to the fine details that were crucial for making the code work, it tended to falter in supplying both adequate code and sufficient instructions for how to remedy any lapses in judgement. Therefore, the quality of the output was solidly middling.\nPerhaps the most notable feature of the LLM’s code was its usage of the SB_HFOSC module, which was extremely similar to the HSOSC one actual utilized for the lab (as briefly talked about above). In the future, if LLM assistance is ever required by a project, more care will be taken to understand the constructs/syntax it employs so as to prompt it to give better, more effective answers."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "This lab built upon the time-multiplexed 7-segment display setup from the previous Lab 2, introducing the additional complication of integrating a 4x4 matrix keypad so that its two most recent key presses would subsequently register on said 7-segment displays. More specifically, the value of the latest key press needed to show on the rightmost display and shift left every time a new input was received, with sufficient compensation for switch bouncing. Note that after an initial key press, the design was required to ignore all following presses until the first had been released. In order to accomplish this, there needed to be robust digital design that could account for the asynchronous nature of all user interactions with the circuit, such that they would not disrupt the outputs and general flow of the remaining synchronized components. Moreover, the design could not comprise any latches or tristate buffers."
  },
  {
    "objectID": "labs/lab3/lab3.html#sec-intro",
    "href": "labs/lab3/lab3.html#sec-intro",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "This lab built upon the time-multiplexed 7-segment display setup from the previous Lab 2, introducing the additional complication of integrating a 4x4 matrix keypad so that its two most recent key presses would subsequently register on said 7-segment displays. More specifically, the value of the latest key press needed to show on the rightmost display and shift left every time a new input was received, with sufficient compensation for switch bouncing. Note that after an initial key press, the design was required to ignore all following presses until the first had been released. In order to accomplish this, there needed to be robust digital design that could account for the asynchronous nature of all user interactions with the circuit, such that they would not disrupt the outputs and general flow of the remaining synchronized components. Moreover, the design could not comprise any latches or tristate buffers."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOverall, there were two inputs — including a reset (reset) and four keypad columns (keypad_column[3:0]) — and three outputs — a row activator (keypad_row[3:0]), transistor toggler (transistor[1:0]), and 7-segment display setter (segment[6:0]) — to the design.\nUsing the default 48 MHz clock produced by the internal oscillator and dividing it to get a slower 24 MHz one, this new signal was fed into an FSM and nested synchronizer. The synchronizer delayed the usage of the keypad_column signal by two cycles in order to mitigate metastability (by providing settling time for any in-between values to stabilize) and meet the aforementioned requirement of asynchronous input-handling.\nAdditionally, as with Lab 2, the 24 MHz clock signal was used to alternate the activation of both transistors at a rate of 100 Hz, which then drove the 7-segment display outputs. Each hexadecimal digit of the 7-segment display was intentionally designed to have a unique appearance. This was reflected in the Verilog code via unique case statements with one toggle-able pin assigned to each segment.\nFurthermore, although the exact workings of the FSM are explained in greater detail down below, know that its most notable features were: 1) the use of both a flip-flop and case statement to store and toggle the FSM’s inputs, outputs, and intermediate signals all at once, and 2) its switch-debouncing strategy. Regarding the former, it was found that it was easiest to just combine the output and state transition signals into one giant module, as it made both conceptually tracking everything and the following, inevitable debugging easier on the programmer. Additionally, when considering the latter, there were a variety of ways that the design could have manifested; however, the final product saw the emergence of a waiting stage that only allowed the most recently and second most recently pressed key locations to update after 0.1 s had passed. This specific time period was chosen because it was deemed to be long enough that the switch bouncing would settle before it was over, but short enough that no additional button presses could occur throughout and be missed.\nWhile there was an initial attempt made to implement a more rigorous method of debouncing involving counting each time a key went high for every single button at the same time, and eventually taking the key with the largest corresponding number as the official debounced result, there were a few concerns that led to that idea being discarded. Namely, the multiple timing violation errors that kept popping up, as well as the fact that this would be expensive and inefficient to implement in actual hardware, anyway.\nThus, the “sit-and-wait” strategy of debouncing manifested and eventually stuck. Its primary tradeoff is that it has a small delay when registering two or more keys that have been pressed in extremely rapid succession. However, because that is an edge case — that the design would still work for, just not as beautifully — and with the current method, there is relatively little hardware implied, a design decision was made to just keep it. If one really wanted to, they could even shorten the wait period to mitigate this “problem.”\nAnother miniscule tradeoff is that there is a tiny delay in the shifting of most recent and second most recent digits (something that is not considered as “clean” as other designs), as a byproduct of assigning the second most recent digit’s value before the most recent digit’s one in the aforementioned FSM. But, again, because this does not functionally compromise the design in any way, shape, or form, a design decision was ruled in favor of keeping everything the same.\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuits and simulation testbenches, as elaborated on in a later Results and Discussion section. Note that there was an individual testbench created for each SystemVerilog module."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram of Verilog design\n\n\n\nThe block diagram in Figure 1 depicts the general architecture implied by the SystemVerilog code. The top-level module, titled “lab3_qm,” comprises a high-speed oscillator module that generates a 48 MHz signal, which is immediately halved in the ensuing “manual_clock_divider” block; this ultimately results in a 24 MHz halved_internal_oscillator clock that is fed to the rest of the time-dependent components. One such component is the “keypad_scanner_and_debouncer” module, which contains an FSM that first stabilizes the column inputs with a “keypad_column_synchronizer,” before determining and subsequently storing the locations of the two most recently pressed keys — all the while simultaneously accounting for debouncing (see below for more details). This then allows “key_to_digit_converter_1” to turn these saved locations into their corresponding hexadecimal values so that they may be interpreted by the “seven_segment_display” and turned into actual, illuminated outputs. Finally, the “seven_segment_display_multiplexer” module alternates the activation status of the two transistors that actually drive the 7-segment displays, and is immediately followed by a mux that decides which digit is showing at any given point in time.\n\n\nFinite State Machine Design\n\n\n\n\n\n\nFigure 2: State transition diagram\n\n\n\nThe Figure 2 FSM illustrates the seven main stages of key detection, switch debouncing, and digit shifting based on recency. Note that the actual Verilog implementation of this FSM is not quite standard, but effective in reaching the end goal nonetheless. After parsing both the code and diagram for the specific signals being toggled, the following Figures 3a and 3b were created for ease of understanding and general transition-tracking.\n\n\n\n\n\n\n\n\n\n\n\n(a) State transition table\n\n\n\n\n\n\n\n\n\n\n\n(b) State output table\n\n\n\n\n\n\n\nFigure 3: FSM design documentation\n\n\n\nIn short, the FSM supplies powers to each row of the keypad, one at a time, until it detects that a column has toggled high in response and moves on; this indicates a key press. Because the column signals have gone through a synchronizer that imposes upon them a two-cycle delay, however, there is a variable actual_toggled_row that accounts for the fact that the rows should actually be offset, as well. Thus, actual_toggled_row stores the row that would have been high two cycles ago when it synced up with the detected column.\nFollowing the scanning stages, the FSM contains a switch-debouncing state that forces the entire system to wait for 0.1 s, therefore allowing any sort of short, echoing “bounces” to settle before proceeding to take the registered input as fact. In this state, the value of what was previously considered the most recent key press is shifted to the left to take the second most recent key press’ place.\nNext, the FSM assembles the segmented row and column information that it has successfully accumulated and forms a more comprehensive key location. It then passes this off as the most recent digit, and waits until there are no more registered presses (between the saved toggled_column value that froze the moment a key press was asserted and any other buttons that may have been pushed in the meantime) to move on to the final stage.\nLastly, the FSM performs a second round of 0.1 s debouncing while resetting both the stored/asserted row and column values to zero, so as not to trigger any false button presses with residual high values when moving back to that very first scanning state.\n\n\nSchematic\n\n\n\n\n\n\nFigure 4: Schematic of physical circuit\n\n\n\nThe Figure 4 schematic outlines how the physical components actually connect. More explicitly, the UPduino_v3.1 FPGA pins demonstrably feed and receive information from the on-board push-button, external MAN6410 7-segment displays, two 2N3906 PNP transistors, 4x4 Adafruit matrix keypad, and resistors of variable values.\nRegarding the latter, firstly, note that the values of the resistors connected to the two transistors and the two 7-segment displays, respectively, were picked after doing the computations depicted in Figure 5 below:\n\n\n\n\n\n\nFigure 5: PNP transistor and 7-segment display resistor math\n\n\n\nAs specified in section 4.17 of the ice40 datasheet for the FPGA (and previously mentioned in the Lab 2 documentation), the current flowing into each GPIO pin should ideally be 8 mA at most. Thus, to justify the the particular resistors chosen, Ohm’s Law was applied to each part of the zoomed-in segment of the main circuit, clearly demonstrating that all current draw fell within recommended operating conditions. Ultimately, for the sake of equal brightness across all segments, seven 160 Ω-resistors were integrated into the 7-segment display circuit, while both transistor bases received current-limiting resistors of 330 Ω. (Sources for the cited transistor information above comprise SparkFun Electronics and Glenn Lockwood. Additionally, the 7-segment display datasheet was used to find the forward voltage necessary to complete the correct calculations.)\nFurthermore, the four pull-down resistors connected to the keypad columns — the top-level Verilog module’s inputs — have values of 1 kΩ, as the circuit in question is a speed-sensitive one."
  },
  {
    "objectID": "labs/lab3/lab3.html#sec-results-and-discussion",
    "href": "labs/lab3/lab3.html#sec-results-and-discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 3 can be viewed in Figure 6 below:\n\n\n\n\n\n\nFigure 6: Demo video\n\n\n\nEvidently, the design met all of the desired specs. While there were some miniscule compromises with regard to key-sensing/toggling speed that had to be made for the sake of more wholistic operation, nothing is objectively wrong with the chosen means of implementation.\n\nTestbench Simulation\n\n\n\n\n\n\n\n\n\n\n\n(a) Clock-divider\n\n\n\n\n\n\n\n\n\n\n\n(b) Keypad synchronizer\n\n\n\n\n\n\n\n\n\n\n\n(c) Key-to-digit converter\n\n\n\n\n\n\n\nFigure 7: Submodule waveforms\n\n\n\nThe submodule waveforms in Figures 7a, 7b, and 7c further verify that the design was working exactly as intended: the clock-divider waveforms proved that the halved_internal_oscillator signal took twice as long as the module’s input to complete a full clock cycle, the synchronizer waveforms showed that the keypad_column inputs were, in fact, being offset by two cycles before being returned as outputs, and the key-to-digit converter waveforms demonstrated that every single activated row-column pairing produced the correct hexadecimal digit.\nThe keypad scanning and debouncing FSM waveforms can be viewed in Figures 8a, 8b, and 8c below. As expected, the FSM was in the correct state at any given point in time, and cycled through them appropriately in response to a variety of inputs, including a short, single key press, a prolonged key press, and key presses that occurred after an initial button was already pushed.\n\n\n\n\n\n\n\n\n\n\n\n(a) Keypad scanner and debouncer module\n\n\n\n\n\n\n\n\n\n\n\n(b) Zoomed-in\n\n\n\n\n\n\n\n\n\n\n\n(c) Zoomed-in\n\n\n\n\n\n\n\nFigure 8: FSM submodule waveforms\n\n\n\nMoreover, the fact that all of these modules were tied together correctly can be verified more explicitly in Figures 9a and 9b, which depict the results of the top module testbench:\n\n\n\n\n\n\n\n\n\n\n\n(a) Top module\n\n\n\n\n\n\n\n\n\n\n\n(b) Zoomed-in\n\n\n\n\n\n\n\nFigure 9: Top module waveforms\n\n\n\nBecause the top module took such an excessively long period of time to run — which was as intended with the integration of two 0.1 s (i.e. 10 Hz) long debouncing states, just unfortunate — only two key presses were actually simulated with it. However, due to the rigorous verification of all the submodules comprising it, this was deemed acceptable, as it still showed that everything was properly interfaced. Evidently, the cycling of which row is powered is shown, as well as the responses to such; when a column going high is detected, the waveforms also demonstrate that the correct toggling of the 7-segment display segments shortly follows (based on the value of output transistor).\nFinally, as can be observed in the Figure 1 block diagram, there were also two 7-segment display-related modules used that — by proper verification standards — should have been simulated. These can be seen in Figures 10a and 10b below. Note that it is the exact same as the ones used in Lab 2.\n\n\n\n\n\n\n\n\n\n\n\n(a) 7-segment display multiplexer\n\n\n\n\n\n\n\n\n\n\n\n(b) 7-segment display\n\n\n\n\n\n\n\nFigure 10: Submodule waveforms\n\n\n\nAll testbenches and simulations passed without the presence of any error messages."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, the design dealt with all user inputs as appropriate, only registering each button press exactly once and only registering the first button press when multiple were active at the same time (until the initial one was released). Furthermore, the 7-segment displays never failed to accurately depict the two most recently pressed keys in the proper order, as outlined above, with no bleeding between digits; its time-multiplexed, 100 Hz toggling was also extremely consistent, with the display-switching going at a rate imperceptible to the naked human eye. A total of approximately 40 hours was spent working on this lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype",
    "href": "labs/lab3/lab3.html#ai-prototype",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the monolithic prompt “Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz). Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices,” the LLM produced results that surprisingly synthesized. These results can be viewed in the associated GitHub repository folder. Additionally, the full response can be seen in the public chat transcript.\nWhile there were no actual errors in the AI code’s synthesis process, the corresponding warning messages can be viewed in Figure 11.\n\n\n\n\n\n\nFigure 11: AI prototype monolithic design warnings\n\n\n\nAdditionally, ChatGPT was asked to respond to the second series of modular prompts, which can be viewed as follows:\n“Target device: Lattice iCE40 UP5K FPGA. Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display. Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior: When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.”\n“Target device: Lattice iCE40 UP5K FPGA. Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior: Iterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.”\n“Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source. Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements: Update the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.”\nThe full response to these modular prompts can be seen in a second, entirely separate chat transcript.\nAgain, the AI’s design synthesized without error, and though the accompanying warnings can be viewed in Figure 12 below, nothing was visibly wrong with its end product upon first glance.\n\n\n\n\n\n\nFigure 12: AI prototype modular design warnings\n\n\n\nOverall, it can be concluded from this little experiment that providing an LLM with both monolithic and modular prompts results in generally similar behavior in the end — or, at the very least, for rather simplistic tasks."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Building off what was learned in the previous Lab 4, three interrupts were interfaced with both the MCU’s internal system clock a timer to perform a constant polling of the pulses produced by a given motor’s quadrature encoder. This information was then converted into an angular velocity by computing a running average over the sampling period, the value of which was then subsequently printed out in the built-in Segger Debug mode terminal, along with the motor’s direction of rotation. Additionally, the written output was configured to auto-update at least every second."
  },
  {
    "objectID": "labs/lab5/lab5.html#sec-intro",
    "href": "labs/lab5/lab5.html#sec-intro",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "Building off what was learned in the previous Lab 4, three interrupts were interfaced with both the MCU’s internal system clock a timer to perform a constant polling of the pulses produced by a given motor’s quadrature encoder. This information was then converted into an angular velocity by computing a running average over the sampling period, the value of which was then subsequently printed out in the built-in Segger Debug mode terminal, along with the motor’s direction of rotation. Additionally, the written output was configured to auto-update at least every second."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5: Interrupts",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nFirstly, the PLL was configured to take in the multispeed internal (MSI) RC oscillator as an input and output an 80 MHz clock signal. Then, pins PA9 and PA10 were set up to take the outputs of the quadrature encoder as inputs, while timer TIM16 was configured to dictate a sampling period of one second. Finally, three different interrupts were enabled, with two tied to PA9 and PA10, respectively, and the last being connected to TIM16; more specifically, the two external interrupts were coded to trigger on every rising and falling edge of the encoder pulses, so as to get the best resolution possible, while the timer interrupt was asserted with the raising of the Update Interrupt Flag in software, which occurred every one second. (Note that some files were not originally produced and were instead taken from the solutions branch of an in-class activity.)\nVarious tests were conducted on the final product, including both physical interaction with the resultant circuit and manual polling, as elaborated on in a later Results and Discussion section."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this project can be found in the associated GitHub repository folder.\n\nSchematic\n\n\n\n\n\n\nFigure 1: Schematic of physical circuit\n\n\n\nThe Figure 1 schematic outlines how the physical components actually connect. PA9 and PA10 were chosen as inputs because they are 5V-tolerant. Note that both quadrature encoders comprise Hall Effect sensors.\n\n\nFlowchart\n\n\n\n\n\n\nFigure 2: Flowchart\n\n\n\nAdditionally, a flowchart illustrating the main steps of the program and function calls can be viewed in Figure 2 above. Because the heavier, calculation-oriented work was done entirely in the three interrupt handlers, the main function does not seemingly comprise much substance.\n\n\nMathematical Verification\nThe speed measured by the MCU can also be mathematically verified to match the true motor speed and direction, as shown in Figure 3 below:\n\n\n\n\n\n\nFigure 3: Motor speed calculations\n\n\n\nIn short, the measured speed displayed was a running average of the total detected pulse edges over a one-second period, the counter for which was incremented by positive one if the motor was turning clockwise and negative one if it was going counterclockwise (no motor movement simply resulted in the counter maintaining its previous value). When given a voltage for which the motor’s actual speed was known, the frequency of PA10 was determined using an oscilloscope and subsequently converted into an angular velocity, so as to provide a more direct and obvious point of comparison."
  },
  {
    "objectID": "labs/lab5/lab5.html#sec-results-and-discussion",
    "href": "labs/lab5/lab5.html#sec-results-and-discussion",
    "title": "Lab 5: Interrupts",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe results of Lab 5 are shown in Figure 4, as follows:\n\n\n\n\n\n\nFigure 4: Demo video\n\n\n\nEvidently, the design performed adequately and exactly to spec. At approximately 10 V, the measured angular velocity was around 2 rev/s, as expected. Furthermore, this velocity value demonstrably had a direct relationship with voltage (as intended), the printed direction of rotation was always accurate, and the terminal very visibly updated at a rate 1 Hz.\n\nManual Polling\nFigures 5a and 5b depict the frequencies at which the MCU is able to toggle a GPIO pin in an empty while loop and a loop that prints an incremented value, respectively.\n\n\n\n\n\n\n\n\n\n\n\n(a) Empty while(1) loop\n\n\n\n\n\n\n\n\n\n\n\n(b) while(1) loop with printing\n\n\n\n\n\n\n\nFigure 5: Oscilloscope traces when manual polling\n\n\n\nMeanwhile, Figure 6 displays the actual pulse frequency received from quadrature encoder B by PA10 (and its attached interrupt handler) when the motor is being supplied 10.13 V; this is the signal that is actually being detected in this lab, and used for all calculations mentioned above.\n\n\n\n\n\n\nFigure 6: Oscilloscope trace of pulses detected by quadrature encoder B\n\n\n\nNow, in order to compare the performance of interrupts as opposed to manual polling in this specific situation, a few calculations were made in Figure 7 below:\n\n\n\n\n\n\nFigure 7: Interrupts vs. manual polling performance comparison\n\n\n\nIn essence, it is always better to use interrupts when it comes to high-speed sampling, though for the sake of this lab, manual polling does not actually perform all that horribly."
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nAll in all, the design utilized three different interrupts to detect rising and falling edges from the two quadrature encoders’ output pulses, accurately extrapolated the motor’s angular velocity and rotational direction from that information, and printed such in the Debug terminal at a rate of at least 1 Hz. A total of approximately 15 hours was spent on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype",
    "href": "labs/lab5/lab5.html#ai-prototype",
    "title": "Lab 5: Interrupts",
    "section": "AI Prototype",
    "text": "AI Prototype\nUsing ChatGPT to generate some code in response to the prompt “Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?,” the LLM produced rather inaccurate results that can be viewed in the public chat transcript. When trying to build its output code, the error message depicted in Figure 8 was produced.\n\n\n\n\n\n\nFigure 8: Build error message for AI code\n\n\n\nThe fact that the AI could not even include the correct header file was indicative of a greater issue at hand — the fact that it could write mostly accurate lines in isolation, but not stitch them together in a way that was usable. Technically, its syntax was correct, but it did not have a good enough understanding of the bigger picture to create something that was properly interfaced.\nHowever, when it came to simply offering advice and not code, the LLM performed much better. For example, in Figure 9, two usable, 5V-tolerant pins were, in fact, recommended.\n\n\n\n\n\n\nFigure 9: ChatGPT MCU pin recommendations\n\n\n\nMoreover, although the AI decided to solve for angular degrees instead of angular velocity, it did output the correct equation for doing so, as shown in Figure 10. However, once again, this line of code only existed in isolation, without any real clarity regarding where to declare it and when it use it.\n\n\n\n\n\n\nFigure 10: ChatGPT angular velocity math\n\n\n\nThus, in summary, the LLM for this week’s AI prototype produced solidly middling results. If perhaps given more instruction as to how the user wants their prompt to be answered, it would likely perform better, but in the meantime, it seems to require significant understanding of interrupts and the task at hand to comprehend what it is trying to do."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflections",
    "section": "",
    "text": "After briefly skimming over the content of our future labs, I am already extremely excited for the semester to come! As someone who wants to specialize in, essentially, ECE (with a little side of mechanical engineering to boot!), this is the perfect course for me; it seems to cover a good amount of the overlap between programming and actual hardware development, which I have always wanted to dive more into. Because I did rather poorly on the exams in E85, I am admittedly also a little nervous for this course’s rigor. However, seeing as E155’s learning is not test-based in the slightest, I do not feel as stressed out about my performance as I could be.\nAt the moment, I do not have any particular ideas in mind for the final project. If possible, I would like to do something that involves working with LEDs (or other lights), for I find such projects satisfyingly aesthetic and fun, but I am not too picky on the content beyond that. I have faith that no matter what, it will be a challenging but ultimately rewarding experience for me.\nMy goals for this semester comprise the following: stay on top of my work, make the most of the resources available to me (including grutors and professors), create a final project that I can be proud of, and maintain an open and positive mindset, even when times get hard. While I would naturally like to succeed academically in this class, I believe that these more soft skill-oriented objectives are just as - if not more - important than attaining good grades. Overall, I hope to come out of this course as both a better engineer and person."
  }
]